### 方法论

* 五毒神掌
* 化繁从简单，找到重复性
* 升维思考
* 艾宾浩斯遗忘曲线

---

### 常见结构

#### 树

* 数的基本遍历方式
    * 前序 ：根左右
    * 中序 ：左根右
    * 后续 ：左右根
 * 常见的遍历实现方式：
     * 递归
     * 栈

#### 图

* 图的基本分类有
    * 无向无权图
    * 有向无权图
    * 无向有权图
* 常见算法
    * DFS
    * BFS


#### 堆

* 可以迅速找打一堆数中的最大或者最小的数据结构
* 基本复杂度(需要基本满足)
    * find-max : O(1)
    * delete-max : O(logN)
    * insert O(logN) O(1)

#### 递归

* 熟记递归代码末班
* 找到重复性(子问题)
* 树的一般形式
* 剥洋葱

#### 回溯

* 尝试试错
* 分布解决单个问题
* 坏情况：导致复杂度为指数级

#### 深度搜索 & 广度搜索

* 每个节点都要访问一次
* 每个节点仅仅要访问一次
* DFS
* BFS

#### 贪心算法

* 每一步的选择都选择当前看来最优的解，希望导致的结果是全局或者是局部最优解
* 和动态规划的区别为，他不可回退

#### 二分查找

必要条件 & 前提

* 目标函数单调递增 & 单调递减
* 存在上下界
* 可以通过索引访问


#### 动态规划的关键点

* 动态规划和递归或者分治没有根本上的区别（关键看有无最优子结构）
* 共性：都需要找到重复的子问题
* 差异性：最优子结构、中途可以淘汰次优解

#### 字典树 

最大限度的减少无谓的字符比较，查询效率比哈希表高

* 节点不存储完整单词
* 根结点到某一个节点，路径上经过的字符临街起来，为该节点对应的字符串
* 每个节点的所有子节点路径代表的字符都不同

拿空间换时间

#### 高级搜索

* 朴素搜索
* 不重复、剪枝
* DFS 、 BFS

#### 二叉搜索树

* 有序的二叉树、排序二叉树
* 左子树 小于 它的根节点
* 右子树 大于 它的根结点

#### 基本操作

* '<<' 左移
* '>>' 右移
* ｜ 按位或
* & 按位与
* ～ 按位去反
* ^ 按位异或

#### 指定位置的位运算

* 将x最右边的N位清零：x & (~0 << n)
* 获取x的第n位值(0或者1):(x>>n)&1
* 获取x的第n位的幂值:x&(1<<n)
* 仅将第n位置为1:x|(1<<n)
* 仅将第n位置为0:x&(~(1<<n))
* 将x最高位至第n位(含)清零:x&((1<<n)-1)

#### 布隆过滤器

可以用于检索一个元素是否在一个集合中

优点：空间效率和查询时间远超一般算法

缺点：有一定的错误率

#### LRU Cache

* hash table + double linkedList

* O(1) 查询、修改、更新

#### 排序

* 计数排序(Counting Sort) 计数排序要求输入的数据必须是有确定范围的整数。将输入的数据值转化为键存 储在额外开辟的数组空间中;然后依次把计数大于 1 的填充回原数组
* 桶排序(Bucket Sort) 桶排序 (Bucket sort)的工作的原理:假设输入数据服从均匀分布，将数据分到 有限数量的桶里，每个桶再分别排序(有可能再使用别的排序算法或是以递归方 式继续使用桶排序进行排)。
* 基数排序(Radix Sort) 基数排序是按照低位先排序，然后收集;再按照高位排序，然后再收集;依次类 推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按 高优先级排序。

#### DP 顺推模板

* 动态规划 和 递归或者分治 没有根本上的区别(关键看有无最优的子结构)
* 拥有共性:找到重复子问题
* 差异性:最优子结构、中途可以淘汰次优解

复杂度来源 

* 状态拥有更多维度(二维、三维、或者更多、甚至需要压缩)
* 状态方程更加复杂

#### Rabin-Karp 算法

* 假设子串的长度为M, 目标字符串的长度为N
* 计算子串的hash值 hash_pat
* 计算机目标字符串txt中每个长度为M的子串hash值
* 比较hash： 如果hash不同，字符串必然不同，如果hash值，还需要使用朴素算法再次判断

--- 


